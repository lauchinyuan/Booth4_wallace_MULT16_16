### 概述

本项目实现了一个计算16bit有符号数*16bit有符号数的高效定点乘法器，使用verilog硬件描述语言进行部署。乘法器输入的被乘数`A_NUM`和乘数`B_NUM`均为16bit定点有符号数，输出为32bit有符号数据。采用Radix-4 Booth算法进行乘数编码，并依据乘数编码生成对应的部分积，接着采用Wallace tree对生成的部分积进行压缩，最后通过一个特殊的32bit加法器将Wallace tree压缩得到的两个部分积进行相加，即得到最终需要的32bit有符号补码数据`C_NUM`。

### 整体原理

本项目乘法器的实现采用了Radix-4 Booth乘数编码算法+Wallace tree方案，其基本原理如下，为了方便公式书写，下文将`A_NUM`、`B_NUM`、`C_NUM`分别简写为`A`、`B`、`C`。

#### Radix-4 Booth算法

Radix-4 Booth乘数编码算法是一种可以减少部分积项数的算法方案，对于一个n位二进制补码数据`B`，其十进制真实值 $B_{D}$ 为：

$$B_{D}=-1 \times B[n-1] \times 2^{n-1}+\sum_{i=0}^{n-2}B[i] \times 2^i \tag{1}$$

式(1)中， $B[i]$ 代表数据`B`的第i位上的值。

对于本项目乘法器输入的16位乘数,代入式(1)，则乘数可以表示为：

$$\begin{align}
B_{D} &= -B[15]2^{15}+B[14]2^{14}+ \cdots +B[0]2^{0} \\
&= (-2B[15]+B[14]+B[13])2^{14} + (-2B[13]+B[12]+B[11])2^{12}+ \cdots + (-2B[1]+B[0]+B[-1])2^{0}\tag{2}
\end{align}$$

被乘数`B`可以使(2)式来表达，将被乘数数据的相邻的三位比特位`B[i]`、`B[i]`、`B[i-1]`视为一个整体，则(2)式与(1)式相比，明显将2的幂次项从16个减少到8个。这样`A`与`B`相乘后的部分积项数也从16个减少到8个，这有利于减少后面为处理部分积而使用的电路资源开销。

Radix-4 Booth编码与所对应的部分积之间的对应关系如表1所示：

<center>表1. Radix-4 Booth乘数编码与部分积对照表</center>

$$
\begin{array}{|c|c|c|}
\hline
{\{B_{i+1},B_{i},B_{i-1}\}}&{-2B_{i+1}+B_{i}+B_{i-1}}&{部分积}\\
\hline
{000}&{0}&{0}\\
\hline
{001}&{+1}&{A}\\
\hline
{010}&{+1}&{A}\\
\hline
{011}&{+2}&{2A}\\
\hline
{100}&{-2}&{-2A}\\
\hline
{101}&{-1}&{-A}\\
\hline
{110}&{-1}&{-A}\\
\hline
{111}&{0}&{0}\\
\hline
\end{array}
$$

使用