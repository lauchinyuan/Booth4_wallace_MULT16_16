### 概述

本项目实现了一个计算16bit有符号数*16bit有符号数的高效定点乘法器，使用verilog硬件描述语言进行部署。乘法器输入的被乘数`A_NUM`和乘数`B_NUM`均为16bit定点有符号数，输出为32bit有符号数据。采用Radix-4 Booth算法进行乘数编码，并依据乘数编码生成对应的部分积，接着采用Wallace tree对生成的部分积进行压缩，最后通过一个特殊的32bit加法器将Wallace tree压缩得到的两个部分积进行相加，即得到最终需要的32bit有符号补码数据`C_NUM`。

### 整体原理

本项目乘法器的实现采用了Radix-4 Booth乘数编码算法+Wallace tree方案，其基本原理如下，为了方便公式书写，下文将`A_NUM`、`B_NUM`、`C_NUM`分别简写为`A`、`B`、`C`。

#### Radix-4 Booth算法

Radix-4 Booth乘数编码算法是一种可以减少部分积项数的算法方案，对于一个n位二进制补码数据`B`，其十进制真实值 $B_{D}$ 为：

$$B_{D}=-1 \times B[n-1] \times 2^{n-1}+\sum_{i=0}^{n-2}B[i] \times 2^i \tag{1}$$

式(1)中， $B[i]$ 代表数据`B`的第i位上的值。

对于本项目乘法器输入的16位乘数,代入式(1)，则乘数可以表示为：

$$\begin{align}
B_{D} &= -B[15]2^{15}+B[14]2^{14}+ \cdots +B[0]2^{0} \\
&= (-2B[15]+B[14]+B[13])2^{14} + (-2B[13]+B[12]+B[11])2^{12}+ \cdots + (-2B[1]+B[0]+B[-1])2^{0}\tag{2}
\end{align}$$

被乘数`B`可以使(2)式来表达，将被乘数数据的相邻的三位比特位`B[i]`、`B[i]`、`B[i-1]`视为一个整体，则(2)式与(1)式相比，明显将2的幂次项从16个减少到8个。这样`A`与`B`相乘后的部分积项数也从16个减少到8个，这有利于减少后面为处理部分积而使用的电路资源开销。

Radix-4 Booth编码与所对应的部分积之间的对应关系如表1所示：

<center>表1. Radix-4 Booth乘数编码与部分积对照表</center>

$$
\begin{array}{|c|c|c|}
\hline
{\{B_{i+1},B_{i},B_{i-1}\}}&{-2B_{i+1}+B_{i}+B_{i-1}}&{部分积}\\
\hline
{000}&{0}&{0}\\
\hline
{001}&{+1}&{A}\\
\hline
{010}&{+1}&{A}\\
\hline
{011}&{+2}&{2A}\\
\hline
{100}&{-2}&{-2A}\\
\hline
{101}&{-1}&{-A}\\
\hline
{110}&{-1}&{-A}\\
\hline
{111}&{0}&{0}\\
\hline
\end{array}
$$

举例来说，对于一个16bit*16bit有符号数的计算，假设被乘数`B`为16'b1000_1000_1100_1110，乘数`A`为16'b1000_1000_1100_1111，首先对乘数进行分段booth解码，分段解码的过程如图1所示。

![](image/booth_decode_example.png)

<center>图1. Radix-4 Booth算法分段解码过程示例</center>

完成booth分段解码后，依据解码值选择相应的booth部分积操作数，Radix-4 Booth算法的竖式运算示意图如图2所示，图中PP代表部分积(partial product),每个pp的操作数都是17bit，因为`-2A`、`2A`都需要17bit来表示。图1中红色部分代表原始数据左移之后在LSB补的0，绿色部分代表符号位扩展的位置。Radix-4 Booth乘法与传统的竖式乘法相比，每进行一位乘法计算，部分积操作数向左移动两位，而不是一位，这是由于(2)式中，相邻的2的幂次项的指数部分相差2，而在(1)式中指数部分相差1。

![](image/booth_mult.png)

<center>图1. Radix-4 Booth竖式乘法运算过程示例</center>

#### wallace乘法器原理

wallce乘法器是一种使用全加器、半加器等模块，将原来多个部分积进行压缩，最终输出两个部分积的一种乘法器结构，wallace乘法器减少了部分积的个数，使得乘法器可以使用更少的加法器来累加部分积，减小了由于乘法器级联而带来的较大的延时。

常用的部分积压缩方案有4:2压缩和3:2压缩，4:2压缩输入4个部分积以及来自上一级压缩器的进位信号(如果存在)，最终生成2个压缩后的部分积。3:2压缩输入3个部分积，最终输出压缩后的两个部分积。

对于16bit*16bit有符号乘法，部分积矩阵如图所示